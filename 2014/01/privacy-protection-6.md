# 如何保护隐私[6]：如何防范“浏览器指纹”？ 

-----

<div class="post-body entry-content">
　　前一篇介绍了“<a href="../../2014/01/privacy-protection-5.md">浏览器指纹的基本概念</a>”今天这篇分享一些防范的技巧。<br/>
<a name="more"></a><br/>
<br/>
<h2>★防范“指纹”的一般性原则？</h2><br/>
　　不管是哪一种特征，要想成为“指纹”至少要具备两个条件：“唯一性”和“稳定性”。比如人类手指的纹路就同时具有“唯一性”和“稳定性”——任意两个人的纹路都不同，而且每个人的纹路终生不变。所以，要对付“指纹识别”，咱们就必须反其道而行——破坏“唯一性”和“稳定性”。对浏览器而言，做到这两点并不难。且听俺细细道来。<br/>
<br/>
<br/>
<h2>★浏览器指纹的关键性信息</h2><br/>
　　<a href="../../2014/01/privacy-protection-5.md">前一篇博文</a>已经给大伙儿介绍了 EFF 的浏览器指纹测试工具（链接在“<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E5%89%8D%E5%93%A8%E5%9F%BA%E9%87%91%E4%BC%9A" rel="nofollow" target="_blank">这里</a>”）。通过这个工具可以明显看出，User Agent 的信息量最大，至少占据一半以上的信息量。换句话说，其它所有特征的信息量加起来都没有 User Agent 大。而且除了 User Agent，其它特征的信息量都比较小。这说明啥捏？<br/>
　　请大伙儿换位思考一下：如果某个网站想要利用浏览器指纹进行用户身份定位，User Agent 是必不可少的一项。缺少这一项，定位的精度会大打折扣。所以，User Agent 是浏览器指纹的关键性信息。<br/>
　　俺已经在博客中多次唠叨了“<a href="../../2009/02/80-20-principle-0-overview.md">二八原理</a>”，浏览器指纹中的 User Agent 就是这关键性的“20%”。下面俺来介绍：如何破坏 User Agent 的“唯一性”和“稳定性”。<br/>
<br/>
<br/>
<h2>★“多浏览器”方案</h2><br/>
　　这个方案最简单，也最容易想到。一看这个小标题，估计大部分读者都猜到俺想喷啥口水。<br/>
　　如果你同时具有两个不同的浏览器（比如：一个 Firefox 一个 Chrome），那么这两个浏览器必然具有不同的 User Agent。如果某个网站收集了浏览器指纹，而你又想在这个网站注册两个不同的马甲，那么你就可以用“多浏览器方案”——分别用不同的浏览器注册不同的马甲。<br/>
　　<b>本方案的优点</b><br/>
　　操作很简单，会装浏览器的同学都玩。<br/>
　　<b>本方案的缺点</b><br/>
　　浏览器的种类毕竟有限（知名且靠谱的浏览器，一只手都能数过来）。万一你想注册十多个马甲，用这个方案就显得傻逼了。<br/>
<br/>
<br/>
<h2>★“多实例”方案</h2><br/>
　　为了解决“多浏览器方案”的局限性，自然会想到“多实例”这个方案。此招数俺曾经在《<a href="../../2010/06/howto-prevent-hacker-attack-0.md">如何防止黑客入侵</a>》系列博文中介绍过。<br/>
　　在主流的三大浏览器中，Firefox 和 Chrome 支持“多实例”，IE 不支持。所以那些喜欢 IE 的同学就没法用这招了。<br/>
　　关于 Firefox 和 Chrome 如何配置多实例，请看俺之前的博文（<a href="../../2012/09/howto-prevent-hacker-attack-6.md">这里</a>）。对于用 Chrome 的同学，俺再次罗嗦一下：Chrome 同时提供“多实例”（洋文叫“Multiple Profiles”）和“多用户”（洋文叫“Multiple Accounts”）两种功能，这两者是完全不同滴。它的“多用户”依然在同一个“实例”中。<br/>
　　<b>配置完“多实例”之后，一定要记得修改每一个实例的 User Agent，并确保【两两不同】。</b>至于如何修改 User Agent 请参见“<a href="../../2013/07/privacy-protection-4.md">这篇博文</a>”——里面提供了三大主流浏览器的修改方法。<br/>
　　<b>本方案的优点</b><br/>
　　浏览器的实例可以配置任意多个（只要你有耐心，硬盘够大，配几百几千都可以）。<br/>
　　<b>本方案的缺点</b><br/>
　　某些浏览器（比如 IE）不支持多实例。<br/>
<br/>
<br/>
<h2>★“多虚拟机”方案</h2><br/>
　　要对付 User Agent 的指纹，前面两招基本够用了。但某些同学可能有特殊需求，或者安全要求比较高，所以俺顺便介绍第三种方法。<br/>
　　第三种方法就是利用虚拟机软件安装不同的虚拟系统，然后在每个虚拟系统中安装浏览器。没用过虚拟化软件的同学，先看俺之前的扫盲教程（在“<a href="../../2012/10/system-vm-0.md">这里</a>”）。再次罗嗦：如果你在不同的虚拟机中安装相同的浏览器，要记得修改【每个】虚拟机中浏览器的 User Agent。<br/>
　　<b>本方案的优点</b><br/>
　　优点1：前面说了，某些浏览器不支持多实例。万一你偏偏喜欢这种浏览器，就可以考虑用“多虚拟机”的方案。<br/>
　　优点2：因为屏幕分辨率、系统时区也都是指纹特征。所以在虚拟系统中，你还可以调整屏幕分辨率和时区（使之不同于你真实系统的分辨率和时区）。<br/>
　　<b>本方案的缺点</b><br/>
　　缺点1：你需要额外安装虚拟化软件，然后再安装虚拟系统。过程稍嫌繁琐。对技术菜鸟也有难度。<br/>
　　缺点2：对系统的硬件有一定的要求（如果你的电脑硬件太寒酸，就甭考虑这招啦）。<br/>
<br/>
<br/>
<h2>★“动态 User Agent”方案</h2><br/>
　　善于思考的同学会发现：前面三个招数，其本质是相通滴。说白了都是利用技术手段“隔离”出不同的浏览器环境，然后单独修改每个环境的指纹，以此来伪造出多个身份。但是对于每一个具体的环境，其指纹依然是固定的。换句话说，前面那三个招数都是针对指纹的【唯一性】。下面俺要介绍的招数可以用来破坏指纹的【稳定性】。<br/>
　　前面说了，浏览器指纹的信息量，至少有一半以上是来自于 User Agent。所以要破坏浏览器指纹的稳定性，只要让浏览器的 User Agent 动态变化即可。下面分别说明技术思路（以下的招数适合于有一定折腾能力的同学，需要用到一点点编写脚本的伎俩）。<br/>
<br/>
<h3>◇如何构造随机的 User Agent</h3><br/>
　　要构造随机的 User Agent ，其实也不难。到“<a href="http://www.useragentstring.com/" rel="nofollow" target="_blank">这个网站</a>”可以看到各种各样浏览器的 User Agent。你可以收集一大堆预存着，然后每次从中随机挑选一条作为你的伪装。为了做到每次随机挑选并设置，你可以写一个脚本来干这事儿，然后顺便让这个脚本来帮你启动浏览器。<br/>
　　再唠叨一下：挑选 User Agent 是有讲究滴，要尽量选择那些比较常见的 User Agent——越常见的 User Agent 所包含的信息量越小。<br/>
<br/>
<h3>◇Firefox</h3><br/>
　　三大浏览器中，最有利于隐私保护的是 Firefox（具体的原因分析请看本系列<a href="../../2013/06/privacy-protection-2.md">前面的博文</a>），所以先说它的技术实现。<br/>
<br/>
　　<b>伪造【静态】的 User Agent</b><br/>
　　以 <code>user.js</code> 的方式定制 Firefox 的配置项——配置项的“名称”是 <code>general.useragent.override</code>，配置项的“值”就是“新的 User Agent”。<br/>
　　定制 Firefox 的方法参见博文：《<a href="../../2019/07/Customize-Firefox.md">扫盲 Firefox 定制——从“user.js”到“omni.ja”</a>》<br/>
<br/>
　　<b>伪造【动态】的 User Agent</b><br/>
　　要做到【动态】的效果，就需要用到【脚本】来自动修改 <code>user.js</code> 文件里面关于 <code>general.useragent.override</code> 的那行代码，生成一个【随机变化】的 User Agent。修改完再用这个脚本把 Firefox 启动起来。<br/>
　　对于 Windows 下的 Firefox，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br/>
　　某些爱思考的同学可能会问，为啥不直接在 <code>user.js</code> 文件里面用 javascript 代码进行 User Agent 的随机生成。<br/>
　　俺也曾经企图这么干，可惜不行！因为 <code>user.js</code> 中对函数 <code>user_pref</code> 的调用，两个参数都必须是【常量】；而且， <code>user.js</code> 中除了调用该函数，不允许再出现其它的代码行。<br/>
<br/>
<h3>◇Chrome</h3><br/>
　　对于 Chrome，可以在命令行参数指定其 User Agent，具体请参见“<a href="../../2013/07/privacy-protection-4.md">这篇博文</a>”。<br/>
　　所以，你只需在脚本中启动 Chrome，每次都传递一个随机的 User Agent 作为命令行参数。<br/>
　　对于 Windows 下的 Chrome，可以用 VBScript 或 JScript 或 PowerShell 这三种系统内置的脚本；对于 Linux 或苹果系统，可以尝试各种 shell 脚本。<br/>
<br/>
<h3>◇IE</h3><br/>
　　对于 IE 的 User Agent，需要修改注册表的键值（<code>HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Internet Settings\User Agent</code>）。所以捏，可以通过事先写好的脚本（VBScript 或 JScript 或 PowerShell）往相应的注册表键值中写入随机的User Agent，然后再由这个脚本启动 IE。<br/>
<br/>
<br/>
<h2>★后记</h2><br/>
　　补充说明几点：<br/>
<br/>
<h3>◇对于“动态 UserAgent 方案”，为啥不直接给出代码</h3><br/>
　　估计肯定有人会抱怨这个。提醒一下：【<b>授人以鱼不如授人以渔</b>】是本博客长期奉行的原则。所以在技术方面，俺更愿意分享一些思路，尽量避免直接给出现成的东西。自己动手实践，有助于能力的提升而且印象更深刻。<br/>
　　如果你是个程序猿/程序媛，写这样一个脚本应该是易如反掌滴；如果你不是搞技术的，顺便学一下简易的脚本编程（其实很容易滴）。不会编程的同学，俺建议从 Python 开始入手，功能强且门槛低，具体请参见《<a href="../../2009/08/why-choose-python-0-overview.md">为啥俺推荐 Python</a>》系列博文。<br/>
<br/>
<h3>◇关于“虚拟系统的屏幕分辨率”</h3><br/>
　　如果你使用“操作系统虚拟机”，需要留意“屏幕分辨率的问题”。<br/>
　　对于【不】使用虚拟机的普通网友，其屏幕分辨率也就是【常见】的那几种（大概在20种以内）——这种情况下，“屏幕分辨率”暴露出的信息量【很低】，不要紧。<br/>
　　但如果你用 Guest OS 上网，并且你【没有】使用全屏模式，那么 Guest OS 的分辨率可能会是一个很奇怪的分辨率（因为独特性很高，会包含【很多】的“指纹信息量”）。所以，俺建议那些用虚拟系统上网的同学，采用如下几个措施：<br/>
<br/>
　　<b>1. 每个 VM 都采用“全屏模式”</b><br/>
　　这个方案针对的是——【普通】的隐私需求。<br/>
　　VM 全都采用【全屏】，虽然每个 VM 的分辨率相同。但至少这个分辨率是某个【常见】的分辨率，因此【信息量很低】。<br/>
<br/>
　　<b>2. 每个 VM 都采用某个常见的分辨率（【非】全屏），且每个 VM 的分辨率【各不相同】</b><br/>
　　这个方案针对的是——【特别高】的隐私需求。<br/>
　　由于每个 VM 的分辨率各不相同，假设网站收集了分辨率作为指纹，不同 VM 的上网身份，会被识别为【不同身份】。<br/>
<br/>
<h3>◇关于“HTML5 的 Canvas 指纹”</h3><br/>
　　在本文发布约半年后，有读者在博客留言中询问了“基于 HTML5 的 Canvas 语法进行指纹追踪”。所以俺单独补充了这一小节。<br/>
　　所谓的“HTML5 的 Canvas 指纹”，依赖的是 HTML5 新增的 Canvas 语法。利用这个 Canvas 语法可以实现一些绘图的功能。由于不同类型的浏览器使用了不同的绘图引擎，所以这可以成为某种指纹信息。<br/>
　　一般情况下，如果你禁用了 JS 脚本，可以让“Canvas 指纹”失效。所以你可以用一些安全扩展（比如 NoScript），对你不信任的网站禁用 JS 脚本。另外，电子前哨基金会（EFF）提供的“Privacy Badger 扩展”，也可以屏蔽“Canvas 指纹”。<br/>
　　要测试自己的浏览器是否存在“Canvas 指纹”，请猛击“<a href="https://www.browserleaks.com/canvas" rel="nofollow" target="_blank">这个链接</a>”。<br/>
　　对于 Firefox，从版本 59 开始，已经引入 RFP（洋文“Resistance Fingerprinting”的缩写），可以限制 Canvas 指纹。<br/>
　　退一步讲，就算你无法屏蔽“Canvas 指纹”，也不用怕。在本文开头提到了“防范指纹的一般性原则？”。其中之一是【破坏唯一性】。你可以用本文介绍的几个招数来破坏唯一性。提醒一下：单纯用“多实例”的招数无法破坏“Canvas 指纹”的唯一性。因为在“多实例”的情况下，每个实例共享同一个浏览器引擎。所以你必须采用“多浏览器”或者“多虚拟机”的方式。<br/>
<br/>
<h3>◇关于 EFF 的浏览器指纹测试</h3><br/>
　　<a href="../../2014/01/privacy-protection-5.md">前一篇博文</a>介绍了 EFF 的浏览器指纹测试工具，估计很多同学都去测试了。其实捏，不必太在意具体每一项的“比特数”。大伙儿只需要关注其“定性”而不必太在意其“定量”。因为 EFF 网站目前收集的样本还不够多（只有几百万），所以其分析出的信息量（相比全球的统计数据）会有所偏差。<br/>
　　另外，很多人测试下来的总信息量是 21.85 bits，这是因为 EFF 的总样本目前只有 370万 左右（370万 约等于“2的21.85次方”）。所以比特数到 21.85 就封顶了。<br/>
<br/>
<br/>
<a href="../../2013/06/privacy-protection-0.md">回到本系列的目录</a>
</div>


------------------------------------------------

版权声明本博客所有的原创文章，作者皆保留版权。转载必须包含本声明，保持本文完整，并以超链接形式注明作者编程随想和本文原始地址：https://program-think.blogspot.com/2014/01/privacy-protection-6.html
